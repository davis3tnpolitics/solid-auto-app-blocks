// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`generator contract snapshots > snapshots api-updator generated contracts 1`] = `
"import { Body, Controller, Delete, Get, Param, Patch, Post, Query } from "@nestjs/common";
import { ApiCreatedResponse, ApiExtraModels, ApiOkResponse, ApiTags, getSchemaPath } from "@nestjs/swagger";
import { User } from "database/contracts/models/User.model";
import { CreateUserDto } from "./dto/create-user.dto";
import { PaginationQueryDto } from "./dto/pagination-query.dto";
import { UpdateUserDto } from "./dto/update-user.dto";
import { UsersService } from "./users.service";

import { SearchUserDto } from "./dto/search-user.dto";

@ApiTags("User")
@ApiExtraModels(User)
@Controller("users")
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  @ApiCreatedResponse({ type: User })
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  @ApiOkResponse({
    schema: {
      type: "object",
      properties: {
        metadata: {
          type: "object",
          properties: {
            pageSize: { type: "number" },
            count: { type: "number" },
            pageCount: { type: "number" },
            pageNumber: { type: "number" },
          },
          required: ["pageSize", "count", "pageCount", "pageNumber"],
        },
        data: {
          type: "object",
          properties: {
            items: {
              type: "array",
              items: { $ref: getSchemaPath(User) },
            },
          },
          required: ["items"],
        },
      },
      required: ["metadata", "data"],
    },
  })
  findAll(@Query() query: PaginationQueryDto) {
    return this.usersService.findAll(query);
  }

  @Post("search")
  @ApiOkResponse({
    schema: {
      type: "object",
      properties: {
        metadata: {
          type: "object",
          properties: {
            pageSize: { type: "number" },
            count: { type: "number" },
            pageCount: { type: "number" },
            pageNumber: { type: "number" },
          },
          required: ["pageSize", "count", "pageCount", "pageNumber"],
        },
        data: {
          type: "object",
          properties: {
            items: {
              type: "array",
              items: { $ref: getSchemaPath(User) },
            },
          },
          required: ["items"],
        },
      },
      required: ["metadata", "data"],
    },
  })
  search(@Body() query: SearchUserDto) {
    return this.usersService.search(query);
  }


  @Get(":id")
  @ApiOkResponse({ type: User })
  findOne(@Param("id") id: string) {
    return this.usersService.findOne(id);
  }

  @Patch(":id")
  @ApiOkResponse({ type: User })
  update(@Param("id") id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(id, updateUserDto);
  }

  @Delete(":id")
  @ApiOkResponse({ type: User })
  remove(@Param("id") id: string) {
    return this.usersService.remove(id);
  }
}
"
`;

exports[`generator contract snapshots > snapshots api-updator generated contracts 2`] = `
"import { Injectable } from "@nestjs/common";
import { createPaginatedResponse, paginate } from "nest-helpers";
import { PrismaService } from "../database/prisma.service";
import { CreateUserDto } from "./dto/create-user.dto";
import { PaginationQueryDto } from "./dto/pagination-query.dto";
import { UpdateUserDto } from "./dto/update-user.dto";

import { Prisma } from "database/client/prisma/client";
import { UserSearchFiltersDto, SearchUserDto } from "./dto/search-user.dto";

@Injectable()
export class UsersService {
  constructor(private readonly prisma: PrismaService) {}

  create(data: CreateUserDto) {
    return this.prisma.user.create({
      data,
    });
  }

  async findAll(query: PaginationQueryDto) {
    const pagination = paginate(query);
    const [items, count] = await Promise.all([
      this.prisma.user.findMany({
        skip: pagination.offset,
        take: pagination.limit,
      }),
      this.prisma.user.count(),
    ]);

    return createPaginatedResponse(items, count, pagination);
  }

  findOne(id: string) {
    return this.prisma.user.findUnique({
      where: { id },
    });
  }

  update(id: string, data: UpdateUserDto) {
    return this.prisma.user.update({
      where: { id },
      data,
    });
  }

  remove(id: string) {
    return this.prisma.user.delete({
      where: { id },
    });
  }

  async search(query: SearchUserDto) {
    const pagination = paginate(query);
    const where = this.buildSearchWhere(query.filters);
    const orderBy = query.sortField
      ? ([{ [query.sortField]: query.sortDirection ?? "asc" }] as Prisma.UserOrderByWithRelationInput[])
      : undefined;

    const [items, count] = await Promise.all([
      this.prisma.user.findMany({
        where,
        orderBy,
        skip: pagination.offset,
        take: pagination.limit,
      }),
      this.prisma.user.count({ where }),
    ]);

    return createPaginatedResponse(items, count, pagination);
  }

  private buildSearchWhere(filters?: UserSearchFiltersDto): Prisma.UserWhereInput {
    if (!filters) return {};

    const where: Prisma.UserWhereInput = {};
    const mutableWhere = where as Record<string, unknown>;
    if (filters.id !== undefined) {
      mutableWhere["id"] = filters.id;
    }
    if (filters.idContains) {
      const filter = this.toFilterObject(mutableWhere["id"]);
      mutableWhere["id"] = {
        ...filter,
        contains: filters.idContains,
        mode: "insensitive",
      };
    }
    if (filters.idIn?.length) {
      const filter = this.toFilterObject(mutableWhere["id"]);
      mutableWhere["id"] = {
        ...filter,
        in: filters.idIn,
      };
    }
    if (filters.email !== undefined) {
      mutableWhere["email"] = filters.email;
    }
    if (filters.emailContains) {
      const filter = this.toFilterObject(mutableWhere["email"]);
      mutableWhere["email"] = {
        ...filter,
        contains: filters.emailContains,
        mode: "insensitive",
      };
    }
    if (filters.emailIn?.length) {
      const filter = this.toFilterObject(mutableWhere["email"]);
      mutableWhere["email"] = {
        ...filter,
        in: filters.emailIn,
      };
    }
    if (filters.name !== undefined) {
      mutableWhere["name"] = filters.name;
    }
    if (filters.nameContains) {
      const filter = this.toFilterObject(mutableWhere["name"]);
      mutableWhere["name"] = {
        ...filter,
        contains: filters.nameContains,
        mode: "insensitive",
      };
    }
    if (filters.nameIn?.length) {
      const filter = this.toFilterObject(mutableWhere["name"]);
      mutableWhere["name"] = {
        ...filter,
        in: filters.nameIn,
      };
    }
    if (filters.age !== undefined) {
      mutableWhere["age"] = filters.age;
    }
    if (
      filters.ageMin !== undefined ||
      filters.ageMax !== undefined ||
      filters.ageIn?.length
    ) {
      const filter = this.toFilterObject(mutableWhere["age"]);
      if (filters.ageMin !== undefined) filter.gte = filters.ageMin;
      if (filters.ageMax !== undefined) filter.lte = filters.ageMax;
      if (filters.ageIn?.length) filter.in = filters.ageIn;
      mutableWhere["age"] = filter;
    }
    if (filters.isActive !== undefined) {
      mutableWhere["isActive"] = filters.isActive;
    }
    if (filters.createdAt) {
      mutableWhere["createdAt"] = new Date(filters.createdAt);
    }
    if (filters.createdAtFrom || filters.createdAtTo) {
      const filter = this.toFilterObject(mutableWhere["createdAt"]);
      if (filters.createdAtFrom) filter.gte = new Date(filters.createdAtFrom);
      if (filters.createdAtTo) filter.lte = new Date(filters.createdAtTo);
      mutableWhere["createdAt"] = filter;
    }
    return where;
  }

  private toFilterObject(value: unknown): Record<string, unknown> {
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      return { ...(value as Record<string, unknown>) };
    }
    return {};
  }
}
"
`;

exports[`generator contract snapshots > snapshots api-updator generated contracts 3`] = `
"import { ApiPropertyOptional } from "@nestjs/swagger";
import { Type } from "class-transformer";
import {
  IsArray,
  IsBoolean,
  IsDateString,
  IsIn,
  IsNumber,
  IsOptional,
  IsString,
  ValidateNested,
} from "class-validator";
import { PaginationQueryDto } from "./pagination-query.dto";

export const UserSortFields = ["id", "email", "name", "age", "isActive", "createdAt"] as const;
export type UserSortField = (typeof UserSortFields)[number];

export class UserSearchFiltersDto {
  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  id?: string;

  @ApiPropertyOptional({ description: "Case-insensitive contains match for id" })
  @IsOptional()
  @IsString()
  idContains?: string;

  @ApiPropertyOptional({ type: [String] })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  idIn?: string[];

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  email?: string;

  @ApiPropertyOptional({ description: "Case-insensitive contains match for email" })
  @IsOptional()
  @IsString()
  emailContains?: string;

  @ApiPropertyOptional({ type: [String] })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  emailIn?: string[];

  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  name?: string;

  @ApiPropertyOptional({ description: "Case-insensitive contains match for name" })
  @IsOptional()
  @IsString()
  nameContains?: string;

  @ApiPropertyOptional({ type: [String] })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  nameIn?: string[];

  @ApiPropertyOptional()
  @IsOptional()
  @IsNumber()
  age?: number;

  @ApiPropertyOptional()
  @IsOptional()
  @IsNumber()
  ageMin?: number;

  @ApiPropertyOptional()
  @IsOptional()
  @IsNumber()
  ageMax?: number;

  @ApiPropertyOptional({ type: [Number] })
  @IsOptional()
  @IsArray()
  @IsNumber({}, { each: true })
  ageIn?: number[];

  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @ApiPropertyOptional({ format: "date-time" })
  @IsOptional()
  @IsDateString()
  createdAt?: string;

  @ApiPropertyOptional({ format: "date-time" })
  @IsOptional()
  @IsDateString()
  createdAtFrom?: string;

  @ApiPropertyOptional({ format: "date-time" })
  @IsOptional()
  @IsDateString()
  createdAtTo?: string;

}

export class SearchUserDto extends PaginationQueryDto {
  @ApiPropertyOptional({ type: () => UserSearchFiltersDto })
  @IsOptional()
  @ValidateNested()
  @Type(() => UserSearchFiltersDto)
  filters?: UserSearchFiltersDto;

  @ApiPropertyOptional({
    enum: UserSortFields,
    description: "Field to sort by",
  })
  @IsOptional()
  @IsIn([...UserSortFields])
  sortField?: UserSortField;

  @ApiPropertyOptional({
    enum: ["asc", "desc"],
    default: "asc",
  })
  @IsOptional()
  @IsIn(["asc", "desc"])
  sortDirection?: "asc" | "desc";
}
"
`;

exports[`generator contract snapshots > snapshots cube-app core files 1`] = `
"{
  "name": "snapshot-cube",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "cubejs-server",
    "start": "cubejs-server",
    "build": "echo \\"Cube app is runtime-first; no build output.\\"",
    "lint": "echo \\"No lint configured for cube app\\"",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "@cubejs-backend/server": "^1.6.14",
    "config": "workspace:*",
    "cube-helpers": "workspace:*",
    "database": "workspace:*"
  },
  "devDependencies": {
    "typescript": "^5.9.3",
    "@types/node": "^20"
  },
  "engines": {
    "node": ">=20.9.0"
  }
}
"
`;

exports[`generator contract snapshots > snapshots cube-app core files 2`] = `
"module.exports = {
  // Use this file for shared driver/context configuration.
  // Schema files are generated under ./model by default.
};
"
`;

exports[`generator contract snapshots > snapshots cube-app core files 3`] = `
"name: App CI (snapshot-cube)

on:
  pull_request:
    paths:
      - "apps/snapshot-cube/**"
      - "packages/**"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - "package.json"
      - ".github/workflows/app-snapshot-cube-ci.yml"
  push:
    branches:
      - main
    paths:
      - "apps/snapshot-cube/**"
      - "packages/**"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - "package.json"
      - ".github/workflows/app-snapshot-cube-ci.yml"
  workflow_dispatch:

concurrency:
  group: app-snapshot-cube-ci-\${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  app-ci:
    name: App App CI
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup PNPM
        uses: pnpm/action-setup@v4
        with:
          version: 10.28.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run lint (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-cube/package.json'); process.exit(pkg.scripts && pkg.scripts.lint ? 0 : 1)"; then
            pnpm --filter snapshot-cube lint
          else
            echo "Skipping lint: no script in apps/snapshot-cube/package.json"
          fi

      - name: Run typecheck (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-cube/package.json'); process.exit(pkg.scripts && pkg.scripts.typecheck ? 0 : 1)"; then
            pnpm --filter snapshot-cube typecheck
          else
            echo "Skipping typecheck: no script in apps/snapshot-cube/package.json"
          fi

      - name: Run tests (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-cube/package.json'); process.exit(pkg.scripts && pkg.scripts.test ? 0 : 1)"; then
            pnpm --filter snapshot-cube test
          else
            echo "Skipping tests: no script in apps/snapshot-cube/package.json"
          fi

      - name: Run build (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-cube/package.json'); process.exit(pkg.scripts && pkg.scripts.build ? 0 : 1)"; then
            pnpm --filter snapshot-cube build
          else
            echo "Skipping build: no script in apps/snapshot-cube/package.json"
          fi

  deploy-placeholder:
    name: Deploy Placeholder
    runs-on: ubuntu-latest
    needs: [app-ci]
    if: \${{ false }}

    steps:
      - name: Deploy hook placeholder
        run: echo "Configure deploy hooks for apps/snapshot-cube at commit \${{ github.sha }}."
"
`;

exports[`generator contract snapshots > snapshots cube-service-updator generated contracts 1`] = `
"import {
  buildCubeService,
  createDefaultDimensions,
  createDefaultMeasures,
  createDefaultPreAggregations,
  createDefaultTimeDimensions,
} from "cube-helpers";

const dimensions = createDefaultDimensions([
  { name: "id", type: "string", primaryKey: true },
  { name: "email", type: "string", primaryKey: false },
  { name: "name", type: "string", primaryKey: false },
  { name: "isActive", type: "boolean", primaryKey: false },
]);

const measures = createDefaultMeasures({
  numericFields: ["age"],
  includeCount: true,
  includeTotals: true,
});

const timeDimensions = createDefaultTimeDimensions(["createdAt"]);

export default buildCubeService({
  cube: "Users",
  sqlTable: "public.users",
  dimensions,
  timeDimensions,
  measures,
  preAggregations: createDefaultPreAggregations({
    timeDimension: "createdAt",
    measureNames: measures.map((measure) => measure.name),
  }),
  securityContext: {
    requiredFilters: ["tenantId"],
  },
});
"
`;

exports[`generator contract snapshots > snapshots cube-service-updator generated contracts 2`] = `
"import type { AnalyticsQueryContract } from "cube-helpers";

export const userAnalyticsContract: AnalyticsQueryContract = {
  cube: "Users",
  dimensions: ["id", "email", "name", "isActive"],
  measures: ["count", "sumAge", "avgAge", "minAge", "maxAge", "totalAge"],
  totals: ["count", "totalAge"],
  timeDimensions: ["createdAt"],
  defaultTimeDimension: "createdAt",
  scopedFilters: ["tenantId"],
};
"
`;

exports[`generator contract snapshots > snapshots nest-app core files 1`] = `
"import "reflect-metadata";
import { ValidationPipe } from "@nestjs/common";
import { NestFactory } from "@nestjs/core";
import { DocumentBuilder, SwaggerModule } from "@nestjs/swagger";
import { getOptionalEnv } from "config";
import { AppModule } from "./app.module";

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { bufferLogs: true });

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidUnknownValues: false,
    })
  );

  const nodeEnv = (getOptionalEnv("NODE_ENV") ?? "development").toLowerCase();
  if (nodeEnv === "development" || nodeEnv === "dev") {
    const swaggerConfig = new DocumentBuilder()
      .setTitle("API")
      .setDescription("API docs")
      .setVersion("1.0.0")
      .build();
    const document = SwaggerModule.createDocument(app, swaggerConfig);
    SwaggerModule.setup("/docs", app, document);
  }

  const port = Number(getOptionalEnv("PORT")) || 3331;
  await app.listen(port);
  console.log(\`API listening on http://localhost:\${port}\`);
}

void bootstrap();
"
`;

exports[`generator contract snapshots > snapshots nest-app core files 2`] = `
"import { UsersModule } from "./users/users.module";
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { HealthModule } from "./health/health.module";
import { PrismaService } from "./database/prisma.service";

@Module({
  imports: [HealthModule, UsersModule],
  controllers: [AppController],
  providers: [AppService, PrismaService],
})
export class AppModule {}
"
`;

exports[`generator contract snapshots > snapshots nest-app core files 3`] = `
"name: App CI (snapshot-api)

on:
  pull_request:
    paths:
      - "apps/snapshot-api/**"
      - "packages/**"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - "package.json"
      - ".github/workflows/app-snapshot-api-ci.yml"
  push:
    branches:
      - main
    paths:
      - "apps/snapshot-api/**"
      - "packages/**"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - "package.json"
      - ".github/workflows/app-snapshot-api-ci.yml"
  workflow_dispatch:

concurrency:
  group: app-snapshot-api-ci-\${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  app-ci:
    name: NestJS App CI
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup PNPM
        uses: pnpm/action-setup@v4
        with:
          version: 10.28.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run lint (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-api/package.json'); process.exit(pkg.scripts && pkg.scripts.lint ? 0 : 1)"; then
            pnpm --filter snapshot-api lint
          else
            echo "Skipping lint: no script in apps/snapshot-api/package.json"
          fi

      - name: Run typecheck (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-api/package.json'); process.exit(pkg.scripts && pkg.scripts.typecheck ? 0 : 1)"; then
            pnpm --filter snapshot-api typecheck
          else
            echo "Skipping typecheck: no script in apps/snapshot-api/package.json"
          fi

      - name: Run tests (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-api/package.json'); process.exit(pkg.scripts && pkg.scripts.test ? 0 : 1)"; then
            pnpm --filter snapshot-api test
          else
            echo "Skipping tests: no script in apps/snapshot-api/package.json"
          fi

      - name: Run build (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-api/package.json'); process.exit(pkg.scripts && pkg.scripts.build ? 0 : 1)"; then
            pnpm --filter snapshot-api build
          else
            echo "Skipping build: no script in apps/snapshot-api/package.json"
          fi

  deploy-placeholder:
    name: Deploy Placeholder
    runs-on: ubuntu-latest
    needs: [app-ci]
    if: \${{ false }}

    steps:
      - name: Deploy hook placeholder
        run: echo "Configure deploy hooks for apps/snapshot-api at commit \${{ github.sha }}."
"
`;

exports[`generator contract snapshots > snapshots next-app core files 1`] = `
"{
  "name": "snapshot-web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
    "typecheck": "tsc --noEmit"
  },
  "dependencies": {
    "next": "16.1.1",
    "next-auth": "^5.0.0-beta.19",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "auth": "workspace:*",
    "communications": "workspace:*",
    "config": "workspace:*",
    "cube-helpers": "workspace:*",
    "database": "workspace:*",
    "nest-helpers": "workspace:*",
    "@workspace/ui": "workspace:*"
  },
  "devDependencies": {
    "typescript": "^5",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.1",
    "@tailwindcss/postcss": "^4",
    "tailwindcss": "^4"
  },
  "engines": {
    "node": ">=18.18.0"
  }
}
"
`;

exports[`generator contract snapshots > snapshots next-app core files 2`] = `
"export default function Page() {
  const workspacePackages = [
  "@workspace/ui",
  "auth",
  "communications",
  "config",
  "cube-helpers",
  "database",
  "nest-helpers"
];

  return (
    <main className="page">
      <header>
        <p className="eyebrow">Next.js App</p>
        <h1>snapshot-web</h1>
        <p>Generated via <code>automations/generators/next-app.js</code>.</p>
      </header>

      <section>
        <h2>Workspace packages</h2>
        <ul>
            <li key="@workspace/ui">@workspace/ui</li>
            <li key="auth">auth</li>
            <li key="communications">communications</li>
            <li key="config">config</li>
            <li key="cube-helpers">cube-helpers</li>
            <li key="database">database</li>
            <li key="nest-helpers">nest-helpers</li>
        </ul>
      </section>
        <section>
          <h2>Getting started</h2>
          <ol>
            <li>Run <code>pnpm install</code> at the repo root.</li>
            <li>Start this app with <code>pnpm --filter snapshot-web dev</code>.</li>
            <li>Add routes or components in <code>src/app</code>.</li>
          </ol>
        </section>

      <section>
        <p>Need API health? Try <code>/api/health</code>.</p>
      </section>
    </main>
  );
}
"
`;

exports[`generator contract snapshots > snapshots next-app core files 3`] = `
"name: App CI (snapshot-web)

on:
  pull_request:
    paths:
      - "apps/snapshot-web/**"
      - "packages/**"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - "package.json"
      - ".github/workflows/app-snapshot-web-ci.yml"
  push:
    branches:
      - main
    paths:
      - "apps/snapshot-web/**"
      - "packages/**"
      - "pnpm-lock.yaml"
      - "pnpm-workspace.yaml"
      - "package.json"
      - ".github/workflows/app-snapshot-web-ci.yml"
  workflow_dispatch:

concurrency:
  group: app-snapshot-web-ci-\${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  app-ci:
    name: Next.js App CI
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup PNPM
        uses: pnpm/action-setup@v4
        with:
          version: 10.28.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run lint (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-web/package.json'); process.exit(pkg.scripts && pkg.scripts.lint ? 0 : 1)"; then
            pnpm --filter snapshot-web lint
          else
            echo "Skipping lint: no script in apps/snapshot-web/package.json"
          fi

      - name: Run typecheck (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-web/package.json'); process.exit(pkg.scripts && pkg.scripts.typecheck ? 0 : 1)"; then
            pnpm --filter snapshot-web typecheck
          else
            echo "Skipping typecheck: no script in apps/snapshot-web/package.json"
          fi

      - name: Run tests (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-web/package.json'); process.exit(pkg.scripts && pkg.scripts.test ? 0 : 1)"; then
            pnpm --filter snapshot-web test
          else
            echo "Skipping tests: no script in apps/snapshot-web/package.json"
          fi

      - name: Run build (if defined)
        run: |
          if node -e "const pkg=require('./apps/snapshot-web/package.json'); process.exit(pkg.scripts && pkg.scripts.build ? 0 : 1)"; then
            pnpm --filter snapshot-web build
          else
            echo "Skipping build: no script in apps/snapshot-web/package.json"
          fi

  deploy-placeholder:
    name: Deploy Placeholder
    runs-on: ubuntu-latest
    needs: [app-ci]
    if: \${{ false }}

    steps:
      - name: Deploy hook placeholder
        run: echo "Configure deploy hooks for apps/snapshot-web at commit \${{ github.sha }}."
"
`;

exports[`generator contract snapshots > snapshots next-crud-pages generated contracts 1`] = `
"import { useInfiniteQuery, useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

import {
  createUser,
  deleteUser,
  getUser,
  listUsers,
  updateUser,
} from "./api";
import { usersQueryKeys } from "./query-keys";
import type {
  CreateUserInput,
  ListUsersParams,
  PaginatedResponse,
  UpdateUserInput,
  User,
} from "./types";

function patchListItems(
  current: PaginatedResponse<User> | undefined,
  updater: (items: User[]) => User[],
  countDelta = 0
): PaginatedResponse<User> | undefined {
  if (!current) return current;

  const nextItems = updater(current.data.items);
  return {
    ...current,
    metadata: {
      ...current.metadata,
      count: Math.max(0, current.metadata.count + countDelta),
    },
    data: {
      ...current.data,
      items: nextItems,
    },
  };
}

export function useUsers(
  params: ListUsersParams = {},
  options?: { enabled?: boolean }
) {
  return useQuery({
    queryKey: usersQueryKeys.list(params),
    queryFn: () => listUsers(params),
    enabled: options?.enabled ?? true,
  });
}

export function useInfiniteUsers(
  params: Omit<ListUsersParams, "page" | "pageNumber" | "offset"> = {},
  options?: { enabled?: boolean }
) {
  return useInfiniteQuery({
    queryKey: usersQueryKeys.list(params),
    initialPageParam: 1,
    queryFn: ({ pageParam }: { pageParam: number }) =>
      listUsers({
        ...params,
        pageNumber: pageParam,
      }),
    getNextPageParam: (lastPage) => {
      const nextPageNumber = lastPage.metadata.pageNumber + 1;
      return nextPageNumber <= lastPage.metadata.pageCount ? nextPageNumber : undefined;
    },
    enabled: options?.enabled ?? true,
  });
}

export function useUser(id?: string) {
  return useQuery({
    queryKey: usersQueryKeys.detail(id || ""),
    queryFn: () => getUser(id as string),
    enabled: Boolean(id),
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (payload: CreateUserInput) => createUser(payload),
    onMutate: async (payload: CreateUserInput) => {
      await queryClient.cancelQueries({ queryKey: usersQueryKeys.lists() });
      const previousLists = queryClient.getQueriesData<PaginatedResponse<User>>({
        queryKey: usersQueryKeys.lists(),
      });

      const optimisticItem = {
        id: "temp-" + Date.now(),
        ...payload,
      } as unknown as User;

      queryClient.setQueriesData<PaginatedResponse<User>>(
        { queryKey: usersQueryKeys.lists() },
        (current) => patchListItems(current, (items) => [optimisticItem, ...items], 1)
      );

      return { previousLists };
    },
    onError: (_error, _payload, context) => {
      (context?.previousLists ?? []).forEach(([queryKey, previous]) => {
        queryClient.setQueryData(queryKey, previous);
      });
    },
    onSuccess: (created) => {
      if ((created as { id?: string }).id) {
        queryClient.setQueryData(
          usersQueryKeys.detail((created as { id: string }).id),
          created
        );
      }
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: usersQueryKeys.lists() });
    },
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, payload }: { id: string; payload: UpdateUserInput }) =>
      updateUser(id, payload),
    onMutate: async (variables: { id: string; payload: UpdateUserInput }) => {
      await Promise.all([
        queryClient.cancelQueries({ queryKey: usersQueryKeys.lists() }),
        queryClient.cancelQueries({ queryKey: usersQueryKeys.detail(variables.id) }),
      ]);

      const previousLists = queryClient.getQueriesData<PaginatedResponse<User>>({
        queryKey: usersQueryKeys.lists(),
      });
      const previousDetail = queryClient.getQueryData<User>(
        usersQueryKeys.detail(variables.id)
      );

      queryClient.setQueryData(
        usersQueryKeys.detail(variables.id),
        previousDetail
          ? ({ ...previousDetail, ...variables.payload } as User)
          : previousDetail
      );

      queryClient.setQueriesData<PaginatedResponse<User>>(
        { queryKey: usersQueryKeys.lists() },
        (current) =>
          patchListItems(current, (items) =>
            items.map((item) =>
              String((item as { id?: unknown }).id) === variables.id
                ? ({ ...item, ...variables.payload } as User)
                : item
            )
          )
      );

      return { previousLists, previousDetail };
    },
    onError: (_error, variables, context) => {
      (context?.previousLists ?? []).forEach(([queryKey, previous]) => {
        queryClient.setQueryData(queryKey, previous);
      });
      if (context?.previousDetail !== undefined) {
        queryClient.setQueryData(usersQueryKeys.detail(variables.id), context.previousDetail);
      }
    },
    onSuccess: (result, variables) => {
      queryClient.setQueryData(usersQueryKeys.detail(variables.id), result);
    },
    onSettled: (_result, _error, variables) => {
      queryClient.invalidateQueries({ queryKey: usersQueryKeys.lists() });
      queryClient.invalidateQueries({ queryKey: usersQueryKeys.detail(variables.id) });
    },
  });
}

export function useDeleteUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => deleteUser(id),
    onMutate: async (id: string) => {
      await Promise.all([
        queryClient.cancelQueries({ queryKey: usersQueryKeys.lists() }),
        queryClient.cancelQueries({ queryKey: usersQueryKeys.detail(id) }),
      ]);

      const previousLists = queryClient.getQueriesData<PaginatedResponse<User>>({
        queryKey: usersQueryKeys.lists(),
      });
      const previousDetail = queryClient.getQueryData<User>(usersQueryKeys.detail(id));

      queryClient.setQueriesData<PaginatedResponse<User>>(
        { queryKey: usersQueryKeys.lists() },
        (current) =>
          patchListItems(
            current,
            (items) =>
              items.filter((item) => String((item as { id?: unknown }).id) !== id),
            -1
          )
      );
      queryClient.removeQueries({ queryKey: usersQueryKeys.detail(id) });

      return { previousLists, previousDetail };
    },
    onError: (_error, id, context) => {
      (context?.previousLists ?? []).forEach(([queryKey, previous]) => {
        queryClient.setQueryData(queryKey, previous);
      });
      if (context?.previousDetail !== undefined) {
        queryClient.setQueryData(usersQueryKeys.detail(id), context.previousDetail);
      }
    },
    onSettled: (_result, _error, id) => {
      queryClient.invalidateQueries({ queryKey: usersQueryKeys.lists() });
      queryClient.removeQueries({ queryKey: usersQueryKeys.detail(id) });
    },
  });
}
"
`;

exports[`generator contract snapshots > snapshots next-crud-pages generated contracts 2`] = `
"import { z } from "zod";

import type { CrudDetailField, CrudFormField, CrudTableColumn } from "@workspace/ui";
import { userCrudOverrides } from "./overrides";

import type { User } from "./types";

const baseCreateUserSchemaShape: Record<string, z.ZodTypeAny> = {
  "email": z.string().min(1, "Required"),
  "name": z.string().min(1, "Required").optional(),
  "age": z.coerce.number().optional(),
  "isActive": z.boolean().optional(),
};

const createUserSchemaShape = Object.fromEntries(
  Object.entries(baseCreateUserSchemaShape).map(([fieldName, schema]) => [
    fieldName,
    userCrudOverrides.validators[fieldName] ?? schema,
  ])
);

export const createUserSchema = z.object(createUserSchemaShape);

export const updateUserSchema = createUserSchema;

export type UserFormValues = z.infer<typeof createUserSchema>;

const baseUserFormFields: CrudFormField<UserFormValues>[] = [
  { name: "email", label: "Email", type: "email" },
  { name: "name", label: "Name", type: "text" },
  { name: "age", label: "Age", type: "number" },
  { name: "isActive", label: "Is Active", type: "checkbox" },
];

export const userFormFields: CrudFormField<UserFormValues>[] = baseUserFormFields
  .filter((field) => !userCrudOverrides.hiddenFields.includes(String(field.name)))
  .map((field) => {
    const fieldName = String(field.name);
    return {
      ...field,
      type: userCrudOverrides.fieldWidgets[fieldName] ?? field.type,
      disabled: field.disabled || userCrudOverrides.readonlyFields.includes(fieldName),
    };
  });

export const userTableColumns: CrudTableColumn<User>[] = [
  { key: "id", header: "Id" },
  { key: "email", header: "Email" },
  { key: "name", header: "Name" },
  { key: "age", header: "Age" },
  { key: "isActive", header: "Is Active" },
];

export const userDetailFields: CrudDetailField<User>[] = [
  { key: "id", label: "Id" },
  { key: "email", label: "Email" },
  { key: "name", label: "Name" },
  { key: "age", label: "Age" },
  { key: "isActive", label: "Is Active" },
  { key: "createdAt", label: "Created At" },
];

export function toUserFormValues(
  record?: Partial<User>
): Partial<UserFormValues> {
  return {
    email: record?.email ?? "",
    name: record?.name ?? "",
    age: record?.age ?? undefined,
    isActive: record?.isActive ?? false,
  };
}
"
`;

exports[`generator contract snapshots > snapshots next-crud-pages generated contracts 3`] = `
""use client";

import * as React from "react";
import Link from "next/link";

import { Button, CrudList, CrudTable } from "@workspace/ui";

import { userTableColumns } from "@/lib/users/config";
import { useUsers, useInfiniteUsers } from "@/lib/users/hooks";
import { crudUiConfig } from "@/lib/crud/ui-config";

const DEFAULT_PAGE_SIZE = 25;

function getErrorMessage(error: unknown) {
  if (error instanceof Error) return error.message;
  return "Unable to load users.";
}

export default function UsersPage() {
  const isInfiniteMode = crudUiConfig.listMode === "infinite";
  const [pageNumber, setPageNumber] = React.useState(1);
  const [pageSize, setPageSize] = React.useState(DEFAULT_PAGE_SIZE);

  const tableQuery = useUsers(
    {
      pageNumber,
      pageSize,
    },
    { enabled: !isInfiniteMode }
  );

  const infiniteQuery = useInfiniteUsers(
    {
      pageSize,
    },
    { enabled: isInfiniteMode }
  );

  const tableRows = tableQuery.data?.data?.items ?? [];
  const infiniteRows = React.useMemo(
    () => (infiniteQuery.data?.pages ?? []).flatMap((page) => page.data?.items ?? []),
    [infiniteQuery.data]
  );
  const rows = isInfiniteMode ? infiniteRows : tableRows;

  const activeLoading = isInfiniteMode ? infiniteQuery.isLoading : tableQuery.isLoading;
  const activeError = isInfiniteMode ? infiniteQuery.error : tableQuery.error;
  const metadata = tableQuery.data?.metadata ?? {
    pageNumber,
    pageSize,
    pageCount: 1,
    count: rows.length,
  };

  return (
    <main className={crudUiConfig.containerClassName}>
      <div className={crudUiConfig.contentClassName}>
        <CrudList
          title="Users"
          description="Browse and manage users."
          isLoading={activeLoading}
          error={activeError ? getErrorMessage(activeError) : null}
          isEmpty={rows.length === 0}
          infiniteScroll={
            isInfiniteMode
              ? {
                  hasMore: Boolean(infiniteQuery.hasNextPage),
                  isLoadingMore: infiniteQuery.isFetchingNextPage,
                  onLoadMore: () => infiniteQuery.fetchNextPage(),
                }
              : undefined
          }
          actions={
            <Button asChild>
              <Link href="/users/create">Create User</Link>
            </Button>
          }
        >
          {isInfiniteMode ? (
            <div className="grid gap-4 sm:grid-cols-2">
              {rows.map((row, index) => (
                <article
                  key={String(row.id ?? index)}
                  className="rounded-lg border bg-card p-4 shadow-sm"
                >
                <p className="text-sm text-muted-foreground"><span className="font-medium text-foreground">Id:</span> {String(row.id ?? "-")}</p>
                <p className="text-sm text-muted-foreground"><span className="font-medium text-foreground">Email:</span> {String(row.email ?? "-")}</p>
                <p className="text-sm text-muted-foreground"><span className="font-medium text-foreground">Name:</span> {String(row.name ?? "-")}</p>
                  <div className="mt-3">
                    <Button asChild variant="outline" size="sm">
                      <Link href={"/users/" + String(row.id ?? "")}>View</Link>
                    </Button>
                  </div>
                </article>
              ))}
            </div>
          ) : (
            <CrudTable
              rows={rows}
              pagination={metadata}
              onPageChange={setPageNumber}
              onPageSizeChange={(nextPageSize) => {
                setPageSize(nextPageSize);
                setPageNumber(1);
              }}
              isPageLoading={tableQuery.isFetching}
              columns={[
                ...userTableColumns,
                {
                  key: "actions",
                  header: "Actions",
                  render: (row) => (
                    <Button asChild variant="outline" size="sm">
                      <Link href={"/users/" + String(row.id ?? "")}>View</Link>
                    </Button>
                  ),
                },
              ]}
            />
          )}
        </CrudList>
      </div>
    </main>
  );
}
"
`;
